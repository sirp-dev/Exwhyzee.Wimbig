/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
      this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    createCategory(model: CreateCategoryDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Category/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    deleteCatgeory(model: CategoryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/DeleteCatgeory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCatgeory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCatgeory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCatgeory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateCategory(model: CategoryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategoryById(id: number | null | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryDto.fromJS(resultData200) : new CategoryDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategoriesBySectionId(id: number | null | undefined): Observable<CategoryDto[]> {
        let url_ = this.baseUrl + "/api/Category/GetCategoriesBySectionId?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoriesBySectionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoriesBySectionId(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoriesBySectionId(response: HttpResponseBase): Observable<CategoryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto[]>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @return Success
     */
    getCategories(status: number | null | undefined, dateStart: string | null | undefined, dateEnd: string | null | undefined, startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined): Observable<PagedListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/GetCategories?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent("" + dateStart) + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent("" + dateEnd) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<PagedListOfCategoryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfCategoryDto.fromJS(resultData200) : new PagedListOfCategoryDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfCategoryDto>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    insertImageDetail(model: ImageFile | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Image/InsertImageDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertImageDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertImageDetail(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsertImageDetail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    deleteSection(model: ImageFile | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Image/DeleteSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSection(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSection(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateCategory2(model: ImageFile | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Image/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategory2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | null | undefined): Observable<ImageFile> {
        let url_ = this.baseUrl + "/api/Image/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ImageFile>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImageFile>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ImageFile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImageFile.fromJS(resultData200) : new ImageFile();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImageFile>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    mapImageToRaffle(model: MapImageToRaffle | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/MapImageToRaffle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMapImageToRaffle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapImageToRaffle(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMapImageToRaffle(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    delete(model: MapImageToRaffle | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update(model: MapImageToRaffle | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMappedImageById(id: number | null | undefined): Observable<MapImageToRaffle> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/GetMappedImageById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappedImageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappedImageById(<any>response_);
                } catch (e) {
                    return <Observable<MapImageToRaffle>><any>_observableThrow(e);
                }
            } else
                return <Observable<MapImageToRaffle>><any>_observableThrow(response_);
        }));
    }

    protected processGetMappedImageById(response: HttpResponseBase): Observable<MapImageToRaffle> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MapImageToRaffle.fromJS(resultData200) : new MapImageToRaffle();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MapImageToRaffle>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param count (optional) 
     * @return Success
     */
    getImagesOfARaffle(id: number | null | undefined, count: number | null | undefined): Observable<ImageOfARaffle[]> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/GetImagesOfARaffle?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImagesOfARaffle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImagesOfARaffle(<any>response_);
                } catch (e) {
                    return <Observable<ImageOfARaffle[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImageOfARaffle[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetImagesOfARaffle(response: HttpResponseBase): Observable<ImageOfARaffle[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImageOfARaffle.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImageOfARaffle[]>(<any>null);
    }

    /**
     * @param purchaseTicket (optional) 
     * @return Success
     */
    processTicket(purchaseTicket: PurchaseTicketDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/PurchaseTicket/ProcessTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(purchaseTicket);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessTicket(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processProcessTicket(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param ticketId (optional) 
     * @return Success
     */
    updateTicket(ticketId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/PurchaseTicket/UpdateTicket?";
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicket(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTicket(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @param raffleId (optional) 
     * @return Success
     */
    getAllTickets(dateStart: string | null | undefined, dateEnd: string | null | undefined, startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined, raffleId: number | null | undefined): Observable<PagedListOfTicketDto> {
        let url_ = this.baseUrl + "/api/PurchaseTicket/GetAllTickets?";
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent("" + dateStart) + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent("" + dateEnd) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        if (raffleId !== undefined)
            url_ += "raffleId=" + encodeURIComponent("" + raffleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTickets(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfTicketDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfTicketDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTickets(response: HttpResponseBase): Observable<PagedListOfTicketDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfTicketDto.fromJS(resultData200) : new PagedListOfTicketDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfTicketDto>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    create(model: RaffleDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Raffle/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    delete2(model: RaffleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Raffle/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    update2(model: RaffleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Raffle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRaffleById(id: number | null | undefined): Observable<RaffleDto> {
        let url_ = this.baseUrl + "/api/Raffle/GetRaffleById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRaffleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleById(<any>response_);
                } catch (e) {
                    return <Observable<RaffleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RaffleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRaffleById(response: HttpResponseBase): Observable<RaffleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RaffleDto.fromJS(resultData200) : new RaffleDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RaffleDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @return Success
     */
    getAllRaflles(status: number | null | undefined, dateStart: string | null | undefined, dateEnd: string | null | undefined, startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined): Observable<PagedListOfRaffleDto> {
        let url_ = this.baseUrl + "/api/Raffle/GetAllRaflles?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent("" + dateStart) + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent("" + dateEnd) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRaflles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRaflles(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfRaffleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfRaffleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRaflles(response: HttpResponseBase): Observable<PagedListOfRaffleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfRaffleDto.fromJS(resultData200) : new PagedListOfRaffleDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfRaffleDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param count (optional) 
     * @return Success
     */
    getRaffleByStatus(status: number | null | undefined, count: number | null | undefined): Observable<RaffleDto[]> {
        let url_ = this.baseUrl + "/api/Raffle/GetRaffleByStatus?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRaffleByStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleByStatus(<any>response_);
                } catch (e) {
                    return <Observable<RaffleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RaffleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRaffleByStatus(response: HttpResponseBase): Observable<RaffleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RaffleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RaffleDto[]>(<any>null);
    }

    /**
     * @param hostedBy (optional) 
     * @param status (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @return Success
     */
    getRaffleByHostedBy(hostedBy: string | null | undefined, status: number | null | undefined, startIndex: number | null | undefined, count: number | null | undefined): Observable<PagedListOfRaffleDto> {
        let url_ = this.baseUrl + "/api/Raffle/GetRaffleByHostedBy?";
        if (hostedBy !== undefined)
            url_ += "hostedBy=" + encodeURIComponent("" + hostedBy) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRaffleByHostedBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleByHostedBy(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfRaffleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfRaffleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRaffleByHostedBy(response: HttpResponseBase): Observable<PagedListOfRaffleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfRaffleDto.fromJS(resultData200) : new PagedListOfRaffleDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfRaffleDto>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    mapRaffleToCategory(model: MapRaffleToCategoryDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/MapRaffleToCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMapRaffleToCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapRaffleToCategory(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMapRaffleToCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    unMapRaffleFromCategpory(model: MapRaffleToCategory | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/UnMapRaffleFromCategpory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnMapRaffleFromCategpory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnMapRaffleFromCategpory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnMapRaffleFromCategpory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateMapping(model: MapRaffleToCategoryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/UpdateMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRaffleToCatgeoryMapById(id: number | null | undefined): Observable<MapRaffleToCategory> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/GetRaffleToCatgeoryMapById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRaffleToCatgeoryMapById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleToCatgeoryMapById(<any>response_);
                } catch (e) {
                    return <Observable<MapRaffleToCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<MapRaffleToCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetRaffleToCatgeoryMapById(response: HttpResponseBase): Observable<MapRaffleToCategory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MapRaffleToCategory.fromJS(resultData200) : new MapRaffleToCategory();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MapRaffleToCategory>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @return Success
     */
    getAll(status: number | null | undefined, dateStart: string | null | undefined, dateEnd: string | null | undefined, startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined): Observable<PagedListOfMapRaffleToCategory> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/GetAll?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent("" + dateStart) + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent("" + dateEnd) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMapRaffleToCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfMapRaffleToCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListOfMapRaffleToCategory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfMapRaffleToCategory.fromJS(resultData200) : new PagedListOfMapRaffleToCategory();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfMapRaffleToCategory>(<any>null);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getAllRafflesMappedToACategory(categoryId: number | null | undefined): Observable<PagedListOfMapRaffleToCategory> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/GetAllRafflesMappedToACategory?";
        if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRafflesMappedToACategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRafflesMappedToACategory(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMapRaffleToCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfMapRaffleToCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRafflesMappedToACategory(response: HttpResponseBase): Observable<PagedListOfMapRaffleToCategory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfMapRaffleToCategory.fromJS(resultData200) : new PagedListOfMapRaffleToCategory();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfMapRaffleToCategory>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    createSection(model: CreateSectionDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Section/CreateSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSection(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSection(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    deleteSection2(model: SectionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Section/DeleteSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSection2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSection2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSection2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateCategory3(model: SectionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Section/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategory3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSectionById(id: number | null | undefined): Observable<SectionDto> {
        let url_ = this.baseUrl + "/api/Section/GetSectionById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectionById(<any>response_);
                } catch (e) {
                    return <Observable<SectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSectionById(response: HttpResponseBase): Observable<SectionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SectionDto.fromJS(resultData200) : new SectionDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectionDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @return Success
     */
    getSections(status: number | null | undefined, dateStart: string | null | undefined, dateEnd: string | null | undefined, startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined): Observable<SectionDto[]> {
        let url_ = this.baseUrl + "/api/Section/GetSections?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent("" + dateStart) + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent("" + dateEnd) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSections(<any>response_);
                } catch (e) {
                    return <Observable<SectionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSections(response: HttpResponseBase): Observable<SectionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SectionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectionDto[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    createTransaction(model: InsertTransactionDto | null | undefined): Observable<TransactionDto> {
        let url_ = this.baseUrl + "/api/Transaction/CreateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransaction(<any>response_);
                } catch (e) {
                    return <Observable<TransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTransaction(response: HttpResponseBase): Observable<TransactionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionDto.fromJS(resultData200) : new TransactionDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionDto>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    updateTransaction(model: TransactionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Transaction/UpdateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransaction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransaction(id: number | null | undefined): Observable<TransactionDto> {
        let url_ = this.baseUrl + "/api/Transaction/GetTransaction?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransaction(<any>response_);
                } catch (e) {
                    return <Observable<TransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransaction(response: HttpResponseBase): Observable<TransactionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionDto.fromJS(resultData200) : new TransactionDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param walletId (optional) 
     * @param status (optional) 
     * @param dateStart (optional) 
     * @param dateEnd (optional) 
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @return Success
     */
    getAllTransactions(userId: string | null | undefined, walletId: number | null | undefined, status: number | null | undefined, dateStart: string | null | undefined, dateEnd: string | null | undefined, startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined): Observable<PagedListOfTransactionDto> {
        let url_ = this.baseUrl + "/api/Transaction/GetAllTransactions?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (walletId !== undefined)
            url_ += "walletId=" + encodeURIComponent("" + walletId) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent("" + dateStart) + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent("" + dateEnd) + "&"; 
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTransactions(response: HttpResponseBase): Observable<PagedListOfTransactionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfTransactionDto.fromJS(resultData200) : new PagedListOfTransactionDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfTransactionDto>(<any>null);
    }

    /**
     * @param wallet (optional) 
     * @return Success
     */
    insertWallet(wallet: InsertWalletDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Wallet/InsertWallet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wallet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertWallet(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsertWallet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param wallet (optional) 
     * @return Success
     */
    updateTicket2(wallet: WalletDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Wallet/UpdateTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wallet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicket2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicket2(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTicket2(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param startIndex (optional) 
     * @param count (optional) 
     * @param searchString (optional) 
     * @return Success
     */
    getAllWallets(startIndex: number | null | undefined, count: number | null | undefined, searchString: string | null | undefined): Observable<PagedListOfWalletDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetAllWallets?";
        if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWallets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWallets(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfWalletDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListOfWalletDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWallets(response: HttpResponseBase): Observable<PagedListOfWalletDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfWalletDto.fromJS(resultData200) : new PagedListOfWalletDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListOfWalletDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getWallet(userId: string | null | undefined): Observable<WalletDto> {
        let url_ = this.baseUrl + "/api/Wallet/GetWallet?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWallet(<any>response_);
                } catch (e) {
                    return <Observable<WalletDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalletDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWallet(response: HttpResponseBase): Observable<WalletDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WalletDto.fromJS(resultData200) : new WalletDto();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalletDto>(<any>null);
    }
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: CreateCategoryDtoEntityStatus | null;
    sectionId?: number | null;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        return data; 
    }
}

export interface ICreateCategoryDto {
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: CreateCategoryDtoEntityStatus | null;
    sectionId?: number | null;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: number | null;
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: CategoryDtoEntityStatus | null;
    sectionId?: number | null;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        return data; 
    }
}

export interface ICategoryDto {
    categoryId?: number | null;
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: CategoryDtoEntityStatus | null;
    sectionId?: number | null;
}

export class PagedListOfCategoryDto implements IPagedListOfCategoryDto {
    source?: CategoryDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;

    constructor(data?: IPagedListOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source!.push(CategoryDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }
}

export interface IPagedListOfCategoryDto {
    source?: CategoryDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;
}

export class ImageFile implements IImageFile {
    id?: number | null;
    url?: string | null;
    extension?: string | null;
    dateCreated?: string | null;
    status?: ImageFileStatus | null;
    isDefault?: boolean | null;

    constructor(data?: IImageFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.extension = data["extension"] !== undefined ? data["extension"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
        }
    }

    static fromJS(data: any): ImageFile {
        data = typeof data === 'object' ? data : {};
        let result = new ImageFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["extension"] = this.extension !== undefined ? this.extension : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        return data; 
    }
}

export interface IImageFile {
    id?: number | null;
    url?: string | null;
    extension?: string | null;
    dateCreated?: string | null;
    status?: ImageFileStatus | null;
    isDefault?: boolean | null;
}

export class MapImageToRaffle implements IMapImageToRaffle {
    id?: number | null;
    raffleId?: number | null;
    imageId?: number | null;
    dateCreated?: string | null;

    constructor(data?: IMapImageToRaffle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.imageId = data["imageId"] !== undefined ? data["imageId"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
        }
    }

    static fromJS(data: any): MapImageToRaffle {
        data = typeof data === 'object' ? data : {};
        let result = new MapImageToRaffle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["imageId"] = this.imageId !== undefined ? this.imageId : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        return data; 
    }
}

export interface IMapImageToRaffle {
    id?: number | null;
    raffleId?: number | null;
    imageId?: number | null;
    dateCreated?: string | null;
}

export class ImageOfARaffle implements IImageOfARaffle {
    id?: number | null;
    raffleId?: number | null;
    imageId?: number | null;
    dateCreated?: string | null;
    url?: string | null;
    extension?: string | null;

    constructor(data?: IImageOfARaffle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.imageId = data["imageId"] !== undefined ? data["imageId"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.extension = data["extension"] !== undefined ? data["extension"] : <any>null;
        }
    }

    static fromJS(data: any): ImageOfARaffle {
        data = typeof data === 'object' ? data : {};
        let result = new ImageOfARaffle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["imageId"] = this.imageId !== undefined ? this.imageId : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["extension"] = this.extension !== undefined ? this.extension : <any>null;
        return data; 
    }
}

export interface IImageOfARaffle {
    id?: number | null;
    raffleId?: number | null;
    imageId?: number | null;
    dateCreated?: string | null;
    url?: string | null;
    extension?: string | null;
}

export class PurchaseTicketDto implements IPurchaseTicketDto {
    transaction?: TransactionDto | null;
    wallet?: WalletDto | null;
    tickets?: InsertTicketDto[] | null;

    constructor(data?: IPurchaseTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transaction = data["transaction"] ? TransactionDto.fromJS(data["transaction"]) : <any>null;
            this.wallet = data["wallet"] ? WalletDto.fromJS(data["wallet"]) : <any>null;
            if (data["tickets"] && data["tickets"].constructor === Array) {
                this.tickets = [] as any;
                for (let item of data["tickets"])
                    this.tickets!.push(InsertTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>null;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>null;
        if (this.tickets && this.tickets.constructor === Array) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPurchaseTicketDto {
    transaction?: TransactionDto | null;
    wallet?: WalletDto | null;
    tickets?: InsertTicketDto[] | null;
}

export class TransactionDto implements ITransactionDto {
    id?: number | null;
    walletId?: number | null;
    userId?: string | null;
    sender?: string | null;
    amount?: number | null;
    dateOfTransaction?: string | null;
    transactionType?: TransactionDtoTransactionType | null;
    status?: TransactionDtoStatus | null;
    username?: string | null;
    transactionReference?: string | null;
    description?: string | null;

    constructor(data?: ITransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.walletId = data["walletId"] !== undefined ? data["walletId"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.sender = data["sender"] !== undefined ? data["sender"] : <any>null;
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.dateOfTransaction = data["dateOfTransaction"] !== undefined ? data["dateOfTransaction"] : <any>null;
            this.transactionType = data["transactionType"] !== undefined ? data["transactionType"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.transactionReference = data["transactionReference"] !== undefined ? data["transactionReference"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["sender"] = this.sender !== undefined ? this.sender : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["dateOfTransaction"] = this.dateOfTransaction !== undefined ? this.dateOfTransaction : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["transactionReference"] = this.transactionReference !== undefined ? this.transactionReference : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface ITransactionDto {
    id?: number | null;
    walletId?: number | null;
    userId?: string | null;
    sender?: string | null;
    amount?: number | null;
    dateOfTransaction?: string | null;
    transactionType?: TransactionDtoTransactionType | null;
    status?: TransactionDtoStatus | null;
    username?: string | null;
    transactionReference?: string | null;
    description?: string | null;
}

export class WalletDto implements IWalletDto {
    id?: number | null;
    userId?: string | null;
    balance?: number | null;
    dateUpdated?: string | null;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.balance = data["balance"] !== undefined ? data["balance"] : <any>null;
            this.dateUpdated = data["dateUpdated"] !== undefined ? data["dateUpdated"] : <any>null;
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["dateUpdated"] = this.dateUpdated !== undefined ? this.dateUpdated : <any>null;
        return data; 
    }
}

export interface IWalletDto {
    id?: number | null;
    userId?: string | null;
    balance?: number | null;
    dateUpdated?: string | null;
}

export class InsertTicketDto implements IInsertTicketDto {
    id?: number | null;
    userId?: string | null;
    raffleId?: number | null;
    ticketNumber?: string | null;
    purchaseDate?: string | null;
    price?: number | null;
    transactionId?: number | null;
    yourPhoneNumber?: string | null;
    ticketStatus?: InsertTicketDtoTicketStatus | null;
    email?: string | null;
    playerName?: string | null;
    currentLocation?: string | null;

    constructor(data?: IInsertTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.ticketNumber = data["ticketNumber"] !== undefined ? data["ticketNumber"] : <any>null;
            this.purchaseDate = data["purchaseDate"] !== undefined ? data["purchaseDate"] : <any>null;
            this.price = data["price"] !== undefined ? data["price"] : <any>null;
            this.transactionId = data["transactionId"] !== undefined ? data["transactionId"] : <any>null;
            this.yourPhoneNumber = data["yourPhoneNumber"] !== undefined ? data["yourPhoneNumber"] : <any>null;
            this.ticketStatus = data["ticketStatus"] !== undefined ? data["ticketStatus"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.playerName = data["playerName"] !== undefined ? data["playerName"] : <any>null;
            this.currentLocation = data["currentLocation"] !== undefined ? data["currentLocation"] : <any>null;
        }
    }

    static fromJS(data: any): InsertTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["ticketNumber"] = this.ticketNumber !== undefined ? this.ticketNumber : <any>null;
        data["purchaseDate"] = this.purchaseDate !== undefined ? this.purchaseDate : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["transactionId"] = this.transactionId !== undefined ? this.transactionId : <any>null;
        data["yourPhoneNumber"] = this.yourPhoneNumber !== undefined ? this.yourPhoneNumber : <any>null;
        data["ticketStatus"] = this.ticketStatus !== undefined ? this.ticketStatus : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["playerName"] = this.playerName !== undefined ? this.playerName : <any>null;
        data["currentLocation"] = this.currentLocation !== undefined ? this.currentLocation : <any>null;
        return data; 
    }
}

export interface IInsertTicketDto {
    id?: number | null;
    userId?: string | null;
    raffleId?: number | null;
    ticketNumber?: string | null;
    purchaseDate?: string | null;
    price?: number | null;
    transactionId?: number | null;
    yourPhoneNumber?: string | null;
    ticketStatus?: InsertTicketDtoTicketStatus | null;
    email?: string | null;
    playerName?: string | null;
    currentLocation?: string | null;
}

export class PagedListOfTicketDto implements IPagedListOfTicketDto {
    source?: TicketDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;

    constructor(data?: IPagedListOfTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source!.push(TicketDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }
}

export interface IPagedListOfTicketDto {
    source?: TicketDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;
}

export class TicketDto implements ITicketDto {
    id?: number | null;
    userId?: string | null;
    userName?: string | null;
    fullName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    raffleId?: number | null;
    raffleName?: string | null;
    raffleNumber?: string | null;
    ticketNumber?: string | null;
    purchaseDate?: string | null;
    transactionId?: number | null;
    price?: number | null;
    isWinner?: boolean | null;
    dateWon?: string | null;
    ticketStatus?: TicketDtoTicketStatus | null;
    isSentToStat?: boolean | null;
    playerName?: string | null;
    date?: string | null;
    status?: number | null;
    paidOut?: boolean | null;
    currentLocation?: string | null;
    walletBal?: number | null;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.userName = data["userName"] !== undefined ? data["userName"] : <any>null;
            this.fullName = data["fullName"] !== undefined ? data["fullName"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.phoneNumber = data["phoneNumber"] !== undefined ? data["phoneNumber"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.raffleNumber = data["raffleNumber"] !== undefined ? data["raffleNumber"] : <any>null;
            this.ticketNumber = data["ticketNumber"] !== undefined ? data["ticketNumber"] : <any>null;
            this.purchaseDate = data["purchaseDate"] !== undefined ? data["purchaseDate"] : <any>null;
            this.transactionId = data["transactionId"] !== undefined ? data["transactionId"] : <any>null;
            this.price = data["price"] !== undefined ? data["price"] : <any>null;
            this.isWinner = data["isWinner"] !== undefined ? data["isWinner"] : <any>null;
            this.dateWon = data["dateWon"] !== undefined ? data["dateWon"] : <any>null;
            this.ticketStatus = data["ticketStatus"] !== undefined ? data["ticketStatus"] : <any>null;
            this.isSentToStat = data["isSentToStat"] !== undefined ? data["isSentToStat"] : <any>null;
            this.playerName = data["playerName"] !== undefined ? data["playerName"] : <any>null;
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.paidOut = data["paidOut"] !== undefined ? data["paidOut"] : <any>null;
            this.currentLocation = data["currentLocation"] !== undefined ? data["currentLocation"] : <any>null;
            this.walletBal = data["walletBal"] !== undefined ? data["walletBal"] : <any>null;
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["raffleNumber"] = this.raffleNumber !== undefined ? this.raffleNumber : <any>null;
        data["ticketNumber"] = this.ticketNumber !== undefined ? this.ticketNumber : <any>null;
        data["purchaseDate"] = this.purchaseDate !== undefined ? this.purchaseDate : <any>null;
        data["transactionId"] = this.transactionId !== undefined ? this.transactionId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["isWinner"] = this.isWinner !== undefined ? this.isWinner : <any>null;
        data["dateWon"] = this.dateWon !== undefined ? this.dateWon : <any>null;
        data["ticketStatus"] = this.ticketStatus !== undefined ? this.ticketStatus : <any>null;
        data["isSentToStat"] = this.isSentToStat !== undefined ? this.isSentToStat : <any>null;
        data["playerName"] = this.playerName !== undefined ? this.playerName : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["paidOut"] = this.paidOut !== undefined ? this.paidOut : <any>null;
        data["currentLocation"] = this.currentLocation !== undefined ? this.currentLocation : <any>null;
        data["walletBal"] = this.walletBal !== undefined ? this.walletBal : <any>null;
        return data; 
    }
}

export interface ITicketDto {
    id?: number | null;
    userId?: string | null;
    userName?: string | null;
    fullName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    raffleId?: number | null;
    raffleName?: string | null;
    raffleNumber?: string | null;
    ticketNumber?: string | null;
    purchaseDate?: string | null;
    transactionId?: number | null;
    price?: number | null;
    isWinner?: boolean | null;
    dateWon?: string | null;
    ticketStatus?: TicketDtoTicketStatus | null;
    isSentToStat?: boolean | null;
    playerName?: string | null;
    date?: string | null;
    status?: number | null;
    paidOut?: boolean | null;
    currentLocation?: string | null;
    walletBal?: number | null;
}

export class RaffleDto implements IRaffleDto {
    id?: number | null;
    name?: string | null;
    description?: string | null;
    numberOfTickets?: number | null;
    pricePerTicket?: number | null;
    hostedBy?: string | null;
    deliveryType?: RaffleDtoDeliveryType | null;
    startDate?: string | null;
    endDate?: string | null;
    status?: RaffleDtoStatus | null;
    dateCreated?: string | null;
    username?: string | null;
    totalSold?: number | null;
    imageUrl?: string | null;
    dateWon?: string | null;
    raffleName?: string | null;
    sortOrder?: number | null;
    archived?: boolean | null;
    paidOut?: boolean | null;
    percentage?: number | null;
    location?: string | null;

    constructor(data?: IRaffleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.numberOfTickets = data["numberOfTickets"] !== undefined ? data["numberOfTickets"] : <any>null;
            this.pricePerTicket = data["pricePerTicket"] !== undefined ? data["pricePerTicket"] : <any>null;
            this.hostedBy = data["hostedBy"] !== undefined ? data["hostedBy"] : <any>null;
            this.deliveryType = data["deliveryType"] !== undefined ? data["deliveryType"] : <any>null;
            this.startDate = data["startDate"] !== undefined ? data["startDate"] : <any>null;
            this.endDate = data["endDate"] !== undefined ? data["endDate"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.totalSold = data["totalSold"] !== undefined ? data["totalSold"] : <any>null;
            this.imageUrl = data["imageUrl"] !== undefined ? data["imageUrl"] : <any>null;
            this.dateWon = data["dateWon"] !== undefined ? data["dateWon"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.sortOrder = data["sortOrder"] !== undefined ? data["sortOrder"] : <any>null;
            this.archived = data["archived"] !== undefined ? data["archived"] : <any>null;
            this.paidOut = data["paidOut"] !== undefined ? data["paidOut"] : <any>null;
            this.percentage = data["percentage"] !== undefined ? data["percentage"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
        }
    }

    static fromJS(data: any): RaffleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RaffleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["numberOfTickets"] = this.numberOfTickets !== undefined ? this.numberOfTickets : <any>null;
        data["pricePerTicket"] = this.pricePerTicket !== undefined ? this.pricePerTicket : <any>null;
        data["hostedBy"] = this.hostedBy !== undefined ? this.hostedBy : <any>null;
        data["deliveryType"] = this.deliveryType !== undefined ? this.deliveryType : <any>null;
        data["startDate"] = this.startDate !== undefined ? this.startDate : <any>null;
        data["endDate"] = this.endDate !== undefined ? this.endDate : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["totalSold"] = this.totalSold !== undefined ? this.totalSold : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["dateWon"] = this.dateWon !== undefined ? this.dateWon : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["sortOrder"] = this.sortOrder !== undefined ? this.sortOrder : <any>null;
        data["archived"] = this.archived !== undefined ? this.archived : <any>null;
        data["paidOut"] = this.paidOut !== undefined ? this.paidOut : <any>null;
        data["percentage"] = this.percentage !== undefined ? this.percentage : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        return data; 
    }
}

export interface IRaffleDto {
    id?: number | null;
    name?: string | null;
    description?: string | null;
    numberOfTickets?: number | null;
    pricePerTicket?: number | null;
    hostedBy?: string | null;
    deliveryType?: RaffleDtoDeliveryType | null;
    startDate?: string | null;
    endDate?: string | null;
    status?: RaffleDtoStatus | null;
    dateCreated?: string | null;
    username?: string | null;
    totalSold?: number | null;
    imageUrl?: string | null;
    dateWon?: string | null;
    raffleName?: string | null;
    sortOrder?: number | null;
    archived?: boolean | null;
    paidOut?: boolean | null;
    percentage?: number | null;
    location?: string | null;
}

export class PagedListOfRaffleDto implements IPagedListOfRaffleDto {
    source?: RaffleDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;

    constructor(data?: IPagedListOfRaffleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source!.push(RaffleDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfRaffleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfRaffleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }
}

export interface IPagedListOfRaffleDto {
    source?: RaffleDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;
}

export class MapRaffleToCategoryDto implements IMapRaffleToCategoryDto {
    id?: number | null;
    raffleId?: number | null;
    raffleName?: string | null;
    categoryId?: number | null;
    categoryName?: string | null;
    dateCreated?: string | null;

    constructor(data?: IMapRaffleToCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.categoryName = data["categoryName"] !== undefined ? data["categoryName"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
        }
    }

    static fromJS(data: any): MapRaffleToCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapRaffleToCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        return data; 
    }
}

export interface IMapRaffleToCategoryDto {
    id?: number | null;
    raffleId?: number | null;
    raffleName?: string | null;
    categoryId?: number | null;
    categoryName?: string | null;
    dateCreated?: string | null;
}

export class MapRaffleToCategory implements IMapRaffleToCategory {
    id?: number | null;
    categoryId?: number | null;
    raffleId?: number | null;
    categoryName?: string | null;
    raffleName?: string | null;
    dateCreated?: string | null;

    constructor(data?: IMapRaffleToCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.categoryName = data["categoryName"] !== undefined ? data["categoryName"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
        }
    }

    static fromJS(data: any): MapRaffleToCategory {
        data = typeof data === 'object' ? data : {};
        let result = new MapRaffleToCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        return data; 
    }
}

export interface IMapRaffleToCategory {
    id?: number | null;
    categoryId?: number | null;
    raffleId?: number | null;
    categoryName?: string | null;
    raffleName?: string | null;
    dateCreated?: string | null;
}

export class PagedListOfMapRaffleToCategory implements IPagedListOfMapRaffleToCategory {
    source?: MapRaffleToCategory[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;

    constructor(data?: IPagedListOfMapRaffleToCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source!.push(MapRaffleToCategory.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfMapRaffleToCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfMapRaffleToCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }
}

export interface IPagedListOfMapRaffleToCategory {
    source?: MapRaffleToCategory[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;
}

export class CreateSectionDto implements ICreateSectionDto {
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: CreateSectionDtoEntityStatus | null;
    sectionId?: number | null;

    constructor(data?: ICreateSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        return data; 
    }
}

export interface ICreateSectionDto {
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: CreateSectionDtoEntityStatus | null;
    sectionId?: number | null;
}

export class SectionDto implements ISectionDto {
    sectionId?: number | null;
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: SectionDtoEntityStatus | null;

    constructor(data?: ISectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] !== undefined ? data["dateCreated"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
        }
    }

    static fromJS(data: any): SectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated !== undefined ? this.dateCreated : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        return data; 
    }
}

export interface ISectionDto {
    sectionId?: number | null;
    name?: string | null;
    dateCreated?: string | null;
    description?: string | null;
    entityStatus?: SectionDtoEntityStatus | null;
}

export class InsertTransactionDto implements IInsertTransactionDto {
    walletId?: number | null;
    userId?: string | null;
    amount?: number | null;
    dateOfTransaction?: string | null;
    transactionType?: InsertTransactionDtoTransactionType | null;
    status?: InsertTransactionDtoStatus | null;
    transactionReference?: string | null;
    description?: string | null;

    constructor(data?: IInsertTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.walletId = data["walletId"] !== undefined ? data["walletId"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.dateOfTransaction = data["dateOfTransaction"] !== undefined ? data["dateOfTransaction"] : <any>null;
            this.transactionType = data["transactionType"] !== undefined ? data["transactionType"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.transactionReference = data["transactionReference"] !== undefined ? data["transactionReference"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): InsertTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["dateOfTransaction"] = this.dateOfTransaction !== undefined ? this.dateOfTransaction : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["transactionReference"] = this.transactionReference !== undefined ? this.transactionReference : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IInsertTransactionDto {
    walletId?: number | null;
    userId?: string | null;
    amount?: number | null;
    dateOfTransaction?: string | null;
    transactionType?: InsertTransactionDtoTransactionType | null;
    status?: InsertTransactionDtoStatus | null;
    transactionReference?: string | null;
    description?: string | null;
}

export class PagedListOfTransactionDto implements IPagedListOfTransactionDto {
    source?: TransactionDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;

    constructor(data?: IPagedListOfTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source!.push(TransactionDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }
}

export interface IPagedListOfTransactionDto {
    source?: TransactionDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;
}

export class InsertWalletDto implements IInsertWalletDto {
    userId?: string | null;
    balance?: number | null;
    dateUpdated?: string | null;

    constructor(data?: IInsertWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.balance = data["balance"] !== undefined ? data["balance"] : <any>null;
            this.dateUpdated = data["dateUpdated"] !== undefined ? data["dateUpdated"] : <any>null;
        }
    }

    static fromJS(data: any): InsertWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["dateUpdated"] = this.dateUpdated !== undefined ? this.dateUpdated : <any>null;
        return data; 
    }
}

export interface IInsertWalletDto {
    userId?: string | null;
    balance?: number | null;
    dateUpdated?: string | null;
}

export class PagedListOfWalletDto implements IPagedListOfWalletDto {
    source?: WalletDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;

    constructor(data?: IPagedListOfWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source!.push(WalletDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }
}

export interface IPagedListOfWalletDto {
    source?: WalletDto[] | null;
    pageIndex?: number | null;
    pageSize?: number | null;
    filteredCount?: number | null;
    totalCount?: number | null;
    totalPages?: number | null;
    hasPreviousPage?: boolean | null;
    hasNextPage?: boolean | null;
}

export enum CreateCategoryDtoEntityStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum CategoryDtoEntityStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum ImageFileStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum TransactionDtoTransactionType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum TransactionDtoStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum InsertTicketDtoTicketStatus {
    _1 = 1, 
    _2 = 2, 
}

export enum TicketDtoTicketStatus {
    _1 = 1, 
    _2 = 2, 
}

export enum RaffleDtoDeliveryType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RaffleDtoStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum CreateSectionDtoEntityStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum SectionDtoEntityStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export enum InsertTransactionDtoTransactionType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum InsertTransactionDtoStatus {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}
