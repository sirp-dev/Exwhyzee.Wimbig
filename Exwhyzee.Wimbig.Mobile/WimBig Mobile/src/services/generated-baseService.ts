/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class CategoryService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    createCategory(model: CreateCategoryDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Category/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    deleteCatgeory(model: CategoryDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/DeleteCatgeory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteCatgeory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCatgeory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteCatgeory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    updateCategory(model: CategoryDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getCategoryById(id: number | undefined): Observable<CategoryDto | null> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CategoryDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<CategoryDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CategoryDto | null>(<any>null);
    }

    getCategoriesBySectionId(id: number | undefined): Observable<CategoryDto[] | null> {
        let url_ = this.baseUrl + "/api/Category/GetCategoriesBySectionId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCategoriesBySectionId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoriesBySectionId(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<CategoryDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCategoriesBySectionId(response: HttpResponseBase): Observable<CategoryDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CategoryDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CategoryDto[] | null>(<any>null);
    }

    getCategories(status: number | null | undefined, dateStart: Date | null | undefined, dateEnd: Date | null | undefined, startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined): Observable<PagedListOfCategoryDto | null> {
        let url_ = this.baseUrl + "/api/Category/GetCategories?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCategories(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfCategoryDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfCategoryDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetCategories(response: HttpResponseBase): Observable<PagedListOfCategoryDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfCategoryDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfCategoryDto | null>(<any>null);
    }
}

@Injectable()
export class ImageService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    insertImageDetail(model: ImageFile): Observable<number> {
        let url_ = this.baseUrl + "/api/Image/InsertImageDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsertImageDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertImageDetail(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processInsertImageDetail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    deleteImgae(model: ImageFile): Observable<string | null> {
        let url_ = this.baseUrl + "/api/Image/DeleteImgae";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteImgae(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImgae(<any>response_);
                } catch (e) {
                    return <Observable<string | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<string | null>><any>Observable.throw(response_);
        });
    }

    protected processDeleteImgae(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string | null>(<any>null);
    }

    updateImage(model: ImageFile): Observable<void> {
        let url_ = this.baseUrl + "/api/Image/UpdateImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateImage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getById(id: number | undefined): Observable<ImageFile | null> {
        let url_ = this.baseUrl + "/api/Image/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ImageFile | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImageFile | null>><any>Observable.throw(response_);
        });
    }

    protected processGetById(response: HttpResponseBase): Observable<ImageFile | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImageFile.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ImageFile | null>(<any>null);
    }
}

@Injectable()
export class ImageToRaffleService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    mapImageToRaffle(model: MapImageToRaffle): Observable<number> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/MapImageToRaffle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processMapImageToRaffle(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapImageToRaffle(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processMapImageToRaffle(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    delete(model: MapImageToRaffle): Observable<void> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    update(model: MapImageToRaffle): Observable<void> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getMappedImageById(id: number | undefined): Observable<MapImageToRaffle | null> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/GetMappedImageById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMappedImageById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappedImageById(<any>response_);
                } catch (e) {
                    return <Observable<MapImageToRaffle | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<MapImageToRaffle | null>><any>Observable.throw(response_);
        });
    }

    protected processGetMappedImageById(response: HttpResponseBase): Observable<MapImageToRaffle | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MapImageToRaffle.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MapImageToRaffle | null>(<any>null);
    }

    getImagesOfARaffle(id: number | undefined, count: number | undefined): Observable<MapImageToRaffle[] | null> {
        let url_ = this.baseUrl + "/api/ImageToRaffle/GetImagesOfARaffle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetImagesOfARaffle(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImagesOfARaffle(<any>response_);
                } catch (e) {
                    return <Observable<MapImageToRaffle[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<MapImageToRaffle[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetImagesOfARaffle(response: HttpResponseBase): Observable<MapImageToRaffle[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MapImageToRaffle.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MapImageToRaffle[] | null>(<any>null);
    }
}

@Injectable()
export class PurchaseTicketService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    processTicket(purchaseTicket: PurchaseTicketDto): Observable<number> {
        let url_ = this.baseUrl + "/api/PurchaseTicket/ProcessTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(purchaseTicket);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processProcessTicket(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessTicket(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processProcessTicket(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    updateTicket(ticketId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/PurchaseTicket/UpdateTicket?";
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTicket(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicket(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTicket(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getAllTickets(dateStart: Date | null | undefined, dateEnd: Date | null | undefined, startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined, raffleId: number | null | undefined): Observable<PagedListOfTicketDto | null> {
        let url_ = this.baseUrl + "/api/PurchaseTicket/GetAllTickets?";
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        if (raffleId !== undefined)
            url_ += "raffleId=" + encodeURIComponent("" + raffleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllTickets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTickets(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfTicketDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfTicketDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllTickets(response: HttpResponseBase): Observable<PagedListOfTicketDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfTicketDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfTicketDto | null>(<any>null);
    }
}

@Injectable()
export class RaffleService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    create(model: RaffleDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Raffle/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    delete(model: RaffleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Raffle/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    update(model: RaffleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Raffle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getRaffleById(id: number | undefined): Observable<RaffleDto | null> {
        let url_ = this.baseUrl + "/api/Raffle/GetRaffleById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRaffleById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleById(<any>response_);
                } catch (e) {
                    return <Observable<RaffleDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<RaffleDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetRaffleById(response: HttpResponseBase): Observable<RaffleDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RaffleDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RaffleDto | null>(<any>null);
    }

    getAllRaflles(status: number | null | undefined, dateStart: Date | null | undefined, dateEnd: Date | null | undefined, startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined): Observable<PagedListOfRaffleDto | null> {
        let url_ = this.baseUrl + "/api/Raffle/GetAllRaflles?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllRaflles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRaflles(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfRaffleDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfRaffleDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllRaflles(response: HttpResponseBase): Observable<PagedListOfRaffleDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfRaffleDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfRaffleDto | null>(<any>null);
    }

    getRaffleByStatus(status: number | undefined, count: number | undefined): Observable<RaffleDto[] | null> {
        let url_ = this.baseUrl + "/api/Raffle/GetRaffleByStatus?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRaffleByStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleByStatus(<any>response_);
                } catch (e) {
                    return <Observable<RaffleDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<RaffleDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetRaffleByStatus(response: HttpResponseBase): Observable<RaffleDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RaffleDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RaffleDto[] | null>(<any>null);
    }

    getRaffleByHostedBy(hostedBy: string | null | undefined, status: number | null | undefined, startIndex: number | undefined, count: number | undefined): Observable<PagedListOfRaffleDto | null> {
        let url_ = this.baseUrl + "/api/Raffle/GetRaffleByHostedBy?";
        if (hostedBy !== undefined)
            url_ += "hostedBy=" + encodeURIComponent("" + hostedBy) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRaffleByHostedBy(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleByHostedBy(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfRaffleDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfRaffleDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetRaffleByHostedBy(response: HttpResponseBase): Observable<PagedListOfRaffleDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfRaffleDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfRaffleDto | null>(<any>null);
    }
}

@Injectable()
export class RaffleToCategoryService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    mapRaffleToCategory(model: MapRaffleToCategoryDto): Observable<number> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/MapRaffleToCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processMapRaffleToCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapRaffleToCategory(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processMapRaffleToCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    unMapRaffleFromCategpory(model: MapRaffleToCategory): Observable<void> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/UnMapRaffleFromCategpory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnMapRaffleFromCategpory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnMapRaffleFromCategpory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnMapRaffleFromCategpory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    updateMapping(model: MapRaffleToCategoryDto): Observable<void> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/UpdateMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateMapping(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getRaffleToCatgeoryMapById(id: number | undefined): Observable<MapRaffleToCategory | null> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/GetRaffleToCatgeoryMapById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRaffleToCatgeoryMapById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRaffleToCatgeoryMapById(<any>response_);
                } catch (e) {
                    return <Observable<MapRaffleToCategory | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<MapRaffleToCategory | null>><any>Observable.throw(response_);
        });
    }

    protected processGetRaffleToCatgeoryMapById(response: HttpResponseBase): Observable<MapRaffleToCategory | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MapRaffleToCategory.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MapRaffleToCategory | null>(<any>null);
    }

    getAll(status: number | null | undefined, dateStart: Date | null | undefined, dateEnd: Date | null | undefined, startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined): Observable<PagedListOfMapRaffleToCategory | null> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/GetAll?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMapRaffleToCategory | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfMapRaffleToCategory | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListOfMapRaffleToCategory | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfMapRaffleToCategory.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfMapRaffleToCategory | null>(<any>null);
    }

    getAllRafflesMappedToACategory(categoryId: number | undefined): Observable<PagedListOfMapRaffleToCategory | null> {
        let url_ = this.baseUrl + "/api/RaffleToCategory/GetAllRafflesMappedToACategory?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllRafflesMappedToACategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRafflesMappedToACategory(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfMapRaffleToCategory | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfMapRaffleToCategory | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllRafflesMappedToACategory(response: HttpResponseBase): Observable<PagedListOfMapRaffleToCategory | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfMapRaffleToCategory.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfMapRaffleToCategory | null>(<any>null);
    }
}

@Injectable()
export class SectionService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    createSection(model: CreateSectionDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Section/CreateSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateSection(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSection(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateSection(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    deleteSection(model: SectionDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Section/DeleteSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteSection(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteSection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    updateCategory(model: SectionDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Section/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getSectionById(id: number | undefined): Observable<SectionDto | null> {
        let url_ = this.baseUrl + "/api/Section/GetSectionById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetSectionById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectionById(<any>response_);
                } catch (e) {
                    return <Observable<SectionDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<SectionDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetSectionById(response: HttpResponseBase): Observable<SectionDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SectionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SectionDto | null>(<any>null);
    }

    getSections(status: number | null | undefined, dateStart: Date | null | undefined, dateEnd: Date | null | undefined, startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined): Observable<SectionDto[] | null> {
        let url_ = this.baseUrl + "/api/Section/GetSections?";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetSections(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSections(<any>response_);
                } catch (e) {
                    return <Observable<SectionDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<SectionDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetSections(response: HttpResponseBase): Observable<SectionDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SectionDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SectionDto[] | null>(<any>null);
    }
}

@Injectable()
export class TransactionService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    createTransaction(model: InsertTransactionDto): Observable<TransactionDto | null> {
        let url_ = this.baseUrl + "/api/Transaction/CreateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransaction(<any>response_);
                } catch (e) {
                    return <Observable<TransactionDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransactionDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateTransaction(response: HttpResponseBase): Observable<TransactionDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TransactionDto | null>(<any>null);
    }

    updateTransaction(model: TransactionDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Transaction/UpdateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransaction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getTransaction(id: number | undefined): Observable<TransactionDto | null> {
        let url_ = this.baseUrl + "/api/Transaction/GetTransaction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransaction(<any>response_);
                } catch (e) {
                    return <Observable<TransactionDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransactionDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetTransaction(response: HttpResponseBase): Observable<TransactionDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TransactionDto | null>(<any>null);
    }

    getAllTransactions(userId: string | null | undefined, walletId: number | null | undefined, status: number | null | undefined, dateStart: Date | null | undefined, dateEnd: Date | null | undefined, startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined): Observable<PagedListOfTransactionDto | null> {
        let url_ = this.baseUrl + "/api/Transaction/GetAllTransactions?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (walletId !== undefined)
            url_ += "walletId=" + encodeURIComponent("" + walletId) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (dateStart !== undefined)
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&"; 
        if (dateEnd !== undefined)
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&"; 
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllTransactions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfTransactionDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfTransactionDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllTransactions(response: HttpResponseBase): Observable<PagedListOfTransactionDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfTransactionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfTransactionDto | null>(<any>null);
    }
}

@Injectable()
export class WalletService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44382";
    }

    insertWallet(wallet: InsertWalletDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Wallet/InsertWallet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wallet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInsertWallet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertWallet(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processInsertWallet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    updateTicket(wallet: WalletDto): Observable<string | null> {
        let url_ = this.baseUrl + "/api/Wallet/UpdateTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wallet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTicket(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicket(<any>response_);
                } catch (e) {
                    return <Observable<string | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<string | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTicket(response: HttpResponseBase): Observable<string | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string | null>(<any>null);
    }

    getAllWallets(startIndex: number | undefined, count: number | undefined, searchString: string | null | undefined): Observable<PagedListOfWalletDto | null> {
        let url_ = this.baseUrl + "/api/Wallet/GetAllWallets?";
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "startIndex=" + encodeURIComponent("" + startIndex) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllWallets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWallets(<any>response_);
                } catch (e) {
                    return <Observable<PagedListOfWalletDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedListOfWalletDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllWallets(response: HttpResponseBase): Observable<PagedListOfWalletDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListOfWalletDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedListOfWalletDto | null>(<any>null);
    }

    getWallet(userId: string | null | undefined): Observable<WalletDto | null> {
        let url_ = this.baseUrl + "/api/Wallet/GetWallet?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetWallet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWallet(<any>response_);
                } catch (e) {
                    return <Observable<WalletDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<WalletDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetWallet(response: HttpResponseBase): Observable<WalletDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WalletDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<WalletDto | null>(<any>null);
    }
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
    sectionId: number;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        return data; 
    }

    clone(): CreateCategoryDto {
        const json = this.toJSON();
        let result = new CreateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCategoryDto {
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
    sectionId: number;
}

export enum EntityStatus {
    Active = 1, 
    Deleted = 2, 
    Pending = 3, 
    Success = 4, 
    Failed = 5, 
    Processing = 6, 
    Drawn = 7, 
    Closed = 8, 
}

export class CategoryDto implements ICategoryDto {
    categoryId: number;
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
    sectionId: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        return data; 
    }

    clone(): CategoryDto {
        const json = this.toJSON();
        let result = new CategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDto {
    categoryId: number;
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
    sectionId: number;
}

export class PagedListOfCategoryDto implements IPagedListOfCategoryDto {
    source?: CategoryDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;

    constructor(data?: IPagedListOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source.push(CategoryDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }

    clone(): PagedListOfCategoryDto {
        const json = this.toJSON();
        let result = new PagedListOfCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedListOfCategoryDto {
    source?: CategoryDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ImageFile implements IImageFile {
    id: number;
    url?: string | null;
    extension?: string | null;
    dateCreated: Date;
    status: EntityStatus;
    isDefault: boolean;

    constructor(data?: IImageFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.extension = data["extension"] !== undefined ? data["extension"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
        }
    }

    static fromJS(data: any): ImageFile {
        data = typeof data === 'object' ? data : {};
        let result = new ImageFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["extension"] = this.extension !== undefined ? this.extension : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        return data; 
    }

    clone(): ImageFile {
        const json = this.toJSON();
        let result = new ImageFile();
        result.init(json);
        return result;
    }
}

export interface IImageFile {
    id: number;
    url?: string | null;
    extension?: string | null;
    dateCreated: Date;
    status: EntityStatus;
    isDefault: boolean;
}

export class MapImageToRaffle implements IMapImageToRaffle {
    id: number;
    raffleId: number;
    imageId: number;
    dateCreated: Date;

    constructor(data?: IMapImageToRaffle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.imageId = data["imageId"] !== undefined ? data["imageId"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): MapImageToRaffle {
        data = typeof data === 'object' ? data : {};
        let result = new MapImageToRaffle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["imageId"] = this.imageId !== undefined ? this.imageId : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        return data; 
    }

    clone(): MapImageToRaffle {
        const json = this.toJSON();
        let result = new MapImageToRaffle();
        result.init(json);
        return result;
    }
}

export interface IMapImageToRaffle {
    id: number;
    raffleId: number;
    imageId: number;
    dateCreated: Date;
}

export class PurchaseTicketDto implements IPurchaseTicketDto {
    transaction?: TransactionDto | null;
    wallet?: WalletDto | null;
    tickets?: InsertTicketDto[] | null;

    constructor(data?: IPurchaseTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transaction = data["transaction"] ? TransactionDto.fromJS(data["transaction"]) : <any>null;
            this.wallet = data["wallet"] ? WalletDto.fromJS(data["wallet"]) : <any>null;
            if (data["tickets"] && data["tickets"].constructor === Array) {
                this.tickets = [] as any;
                for (let item of data["tickets"])
                    this.tickets.push(InsertTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>null;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>null;
        if (this.tickets && this.tickets.constructor === Array) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PurchaseTicketDto {
        const json = this.toJSON();
        let result = new PurchaseTicketDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseTicketDto {
    transaction?: TransactionDto | null;
    wallet?: WalletDto | null;
    tickets?: InsertTicketDto[] | null;
}

export class TransactionDto implements ITransactionDto {
    id: number;
    walletId: number;
    userId?: string | null;
    sender?: string | null;
    amount: number;
    dateOfTransaction: Date;
    transactionType: TransactionTypeEnum;
    status: EntityStatus;
    username?: string | null;
    transactionReference?: string | null;
    description?: string | null;

    constructor(data?: ITransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.walletId = data["walletId"] !== undefined ? data["walletId"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.sender = data["sender"] !== undefined ? data["sender"] : <any>null;
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.dateOfTransaction = data["dateOfTransaction"] ? new Date(data["dateOfTransaction"].toString()) : <any>null;
            this.transactionType = data["transactionType"] !== undefined ? data["transactionType"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.transactionReference = data["transactionReference"] !== undefined ? data["transactionReference"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): TransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["sender"] = this.sender !== undefined ? this.sender : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["dateOfTransaction"] = this.dateOfTransaction ? this.dateOfTransaction.toISOString() : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["transactionReference"] = this.transactionReference !== undefined ? this.transactionReference : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }

    clone(): TransactionDto {
        const json = this.toJSON();
        let result = new TransactionDto();
        result.init(json);
        return result;
    }
}

export interface ITransactionDto {
    id: number;
    walletId: number;
    userId?: string | null;
    sender?: string | null;
    amount: number;
    dateOfTransaction: Date;
    transactionType: TransactionTypeEnum;
    status: EntityStatus;
    username?: string | null;
    transactionReference?: string | null;
    description?: string | null;
}

export enum TransactionTypeEnum {
    Debit = 1, 
    Credit = 2, 
    TransferDebit = 3, 
    TransferCredit = 4, 
}

export class WalletDto implements IWalletDto {
    id: number;
    userId?: string | null;
    balance: number;
    dateUpdated: Date;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.balance = data["balance"] !== undefined ? data["balance"] : <any>null;
            this.dateUpdated = data["dateUpdated"] ? new Date(data["dateUpdated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>null;
        return data; 
    }

    clone(): WalletDto {
        const json = this.toJSON();
        let result = new WalletDto();
        result.init(json);
        return result;
    }
}

export interface IWalletDto {
    id: number;
    userId?: string | null;
    balance: number;
    dateUpdated: Date;
}

export class InsertTicketDto implements IInsertTicketDto {
    id: number;
    userId?: string | null;
    raffleId: number;
    ticketNumber?: string | null;
    purchaseDate: Date;
    price: number;
    transactionId: number;
    yourPhoneNumber?: string | null;
    ticketStatus: TicketStatusEnum;
    email?: string | null;
    playerName?: string | null;
    currentLocation?: string | null;

    constructor(data?: IInsertTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.ticketNumber = data["ticketNumber"] !== undefined ? data["ticketNumber"] : <any>null;
            this.purchaseDate = data["purchaseDate"] ? new Date(data["purchaseDate"].toString()) : <any>null;
            this.price = data["price"] !== undefined ? data["price"] : <any>null;
            this.transactionId = data["transactionId"] !== undefined ? data["transactionId"] : <any>null;
            this.yourPhoneNumber = data["yourPhoneNumber"] !== undefined ? data["yourPhoneNumber"] : <any>null;
            this.ticketStatus = data["ticketStatus"] !== undefined ? data["ticketStatus"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.playerName = data["playerName"] !== undefined ? data["playerName"] : <any>null;
            this.currentLocation = data["currentLocation"] !== undefined ? data["currentLocation"] : <any>null;
        }
    }

    static fromJS(data: any): InsertTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["ticketNumber"] = this.ticketNumber !== undefined ? this.ticketNumber : <any>null;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["transactionId"] = this.transactionId !== undefined ? this.transactionId : <any>null;
        data["yourPhoneNumber"] = this.yourPhoneNumber !== undefined ? this.yourPhoneNumber : <any>null;
        data["ticketStatus"] = this.ticketStatus !== undefined ? this.ticketStatus : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["playerName"] = this.playerName !== undefined ? this.playerName : <any>null;
        data["currentLocation"] = this.currentLocation !== undefined ? this.currentLocation : <any>null;
        return data; 
    }

    clone(): InsertTicketDto {
        const json = this.toJSON();
        let result = new InsertTicketDto();
        result.init(json);
        return result;
    }
}

export interface IInsertTicketDto {
    id: number;
    userId?: string | null;
    raffleId: number;
    ticketNumber?: string | null;
    purchaseDate: Date;
    price: number;
    transactionId: number;
    yourPhoneNumber?: string | null;
    ticketStatus: TicketStatusEnum;
    email?: string | null;
    playerName?: string | null;
    currentLocation?: string | null;
}

export enum TicketStatusEnum {
    Active = 1, 
    Drawn = 2, 
}

export class PagedListOfTicketDto implements IPagedListOfTicketDto {
    source?: TicketDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;

    constructor(data?: IPagedListOfTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source.push(TicketDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }

    clone(): PagedListOfTicketDto {
        const json = this.toJSON();
        let result = new PagedListOfTicketDto();
        result.init(json);
        return result;
    }
}

export interface IPagedListOfTicketDto {
    source?: TicketDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class TicketDto implements ITicketDto {
    id: number;
    userId?: string | null;
    userName?: string | null;
    fullName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    raffleId: number;
    raffleName?: string | null;
    raffleNumber?: string | null;
    ticketNumber?: string | null;
    purchaseDate: Date;
    transactionId: number;
    price: number;
    isWinner: boolean;
    dateWon?: Date | null;
    ticketStatus: TicketStatusEnum;
    isSentToStat: boolean;
    playerName?: string | null;
    date: Date;
    status: number;
    paidOut: boolean;
    currentLocation?: string | null;
    walletBal: number;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.userName = data["userName"] !== undefined ? data["userName"] : <any>null;
            this.fullName = data["fullName"] !== undefined ? data["fullName"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.phoneNumber = data["phoneNumber"] !== undefined ? data["phoneNumber"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.raffleNumber = data["raffleNumber"] !== undefined ? data["raffleNumber"] : <any>null;
            this.ticketNumber = data["ticketNumber"] !== undefined ? data["ticketNumber"] : <any>null;
            this.purchaseDate = data["purchaseDate"] ? new Date(data["purchaseDate"].toString()) : <any>null;
            this.transactionId = data["transactionId"] !== undefined ? data["transactionId"] : <any>null;
            this.price = data["price"] !== undefined ? data["price"] : <any>null;
            this.isWinner = data["isWinner"] !== undefined ? data["isWinner"] : <any>null;
            this.dateWon = data["dateWon"] ? new Date(data["dateWon"].toString()) : <any>null;
            this.ticketStatus = data["ticketStatus"] !== undefined ? data["ticketStatus"] : <any>null;
            this.isSentToStat = data["isSentToStat"] !== undefined ? data["isSentToStat"] : <any>null;
            this.playerName = data["playerName"] !== undefined ? data["playerName"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.paidOut = data["paidOut"] !== undefined ? data["paidOut"] : <any>null;
            this.currentLocation = data["currentLocation"] !== undefined ? data["currentLocation"] : <any>null;
            this.walletBal = data["walletBal"] !== undefined ? data["walletBal"] : <any>null;
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["raffleNumber"] = this.raffleNumber !== undefined ? this.raffleNumber : <any>null;
        data["ticketNumber"] = this.ticketNumber !== undefined ? this.ticketNumber : <any>null;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>null;
        data["transactionId"] = this.transactionId !== undefined ? this.transactionId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["isWinner"] = this.isWinner !== undefined ? this.isWinner : <any>null;
        data["dateWon"] = this.dateWon ? this.dateWon.toISOString() : <any>null;
        data["ticketStatus"] = this.ticketStatus !== undefined ? this.ticketStatus : <any>null;
        data["isSentToStat"] = this.isSentToStat !== undefined ? this.isSentToStat : <any>null;
        data["playerName"] = this.playerName !== undefined ? this.playerName : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["paidOut"] = this.paidOut !== undefined ? this.paidOut : <any>null;
        data["currentLocation"] = this.currentLocation !== undefined ? this.currentLocation : <any>null;
        data["walletBal"] = this.walletBal !== undefined ? this.walletBal : <any>null;
        return data; 
    }

    clone(): TicketDto {
        const json = this.toJSON();
        let result = new TicketDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDto {
    id: number;
    userId?: string | null;
    userName?: string | null;
    fullName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    raffleId: number;
    raffleName?: string | null;
    raffleNumber?: string | null;
    ticketNumber?: string | null;
    purchaseDate: Date;
    transactionId: number;
    price: number;
    isWinner: boolean;
    dateWon?: Date | null;
    ticketStatus: TicketStatusEnum;
    isSentToStat: boolean;
    playerName?: string | null;
    date: Date;
    status: number;
    paidOut: boolean;
    currentLocation?: string | null;
    walletBal: number;
}

export class RaffleDto implements IRaffleDto {
    id: number;
    name?: string | null;
    description?: string | null;
    numberOfTickets: number;
    pricePerTicket: number;
    hostedBy?: string | null;
    deliveryType: DeliveryTypeEnum;
    startDate: Date;
    endDate: Date;
    status: EntityStatus;
    dateCreated: Date;
    username?: string | null;
    totalSold: number;
    imageUrl?: string | null;
    dateWon?: Date | null;
    raffleName?: string | null;
    sortOrder: number;
    archived: boolean;
    paidOut: boolean;
    percentage: number;
    location?: string | null;

    constructor(data?: IRaffleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.numberOfTickets = data["numberOfTickets"] !== undefined ? data["numberOfTickets"] : <any>null;
            this.pricePerTicket = data["pricePerTicket"] !== undefined ? data["pricePerTicket"] : <any>null;
            this.hostedBy = data["hostedBy"] !== undefined ? data["hostedBy"] : <any>null;
            this.deliveryType = data["deliveryType"] !== undefined ? data["deliveryType"] : <any>null;
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>null;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.totalSold = data["totalSold"] !== undefined ? data["totalSold"] : <any>null;
            this.imageUrl = data["imageUrl"] !== undefined ? data["imageUrl"] : <any>null;
            this.dateWon = data["dateWon"] ? new Date(data["dateWon"].toString()) : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.sortOrder = data["sortOrder"] !== undefined ? data["sortOrder"] : <any>null;
            this.archived = data["archived"] !== undefined ? data["archived"] : <any>null;
            this.paidOut = data["paidOut"] !== undefined ? data["paidOut"] : <any>null;
            this.percentage = data["percentage"] !== undefined ? data["percentage"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
        }
    }

    static fromJS(data: any): RaffleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RaffleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["numberOfTickets"] = this.numberOfTickets !== undefined ? this.numberOfTickets : <any>null;
        data["pricePerTicket"] = this.pricePerTicket !== undefined ? this.pricePerTicket : <any>null;
        data["hostedBy"] = this.hostedBy !== undefined ? this.hostedBy : <any>null;
        data["deliveryType"] = this.deliveryType !== undefined ? this.deliveryType : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["totalSold"] = this.totalSold !== undefined ? this.totalSold : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["dateWon"] = this.dateWon ? this.dateWon.toISOString() : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["sortOrder"] = this.sortOrder !== undefined ? this.sortOrder : <any>null;
        data["archived"] = this.archived !== undefined ? this.archived : <any>null;
        data["paidOut"] = this.paidOut !== undefined ? this.paidOut : <any>null;
        data["percentage"] = this.percentage !== undefined ? this.percentage : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        return data; 
    }

    clone(): RaffleDto {
        const json = this.toJSON();
        let result = new RaffleDto();
        result.init(json);
        return result;
    }
}

export interface IRaffleDto {
    id: number;
    name?: string | null;
    description?: string | null;
    numberOfTickets: number;
    pricePerTicket: number;
    hostedBy?: string | null;
    deliveryType: DeliveryTypeEnum;
    startDate: Date;
    endDate: Date;
    status: EntityStatus;
    dateCreated: Date;
    username?: string | null;
    totalSold: number;
    imageUrl?: string | null;
    dateWon?: Date | null;
    raffleName?: string | null;
    sortOrder: number;
    archived: boolean;
    paidOut: boolean;
    percentage: number;
    location?: string | null;
}

export enum DeliveryTypeEnum {
    Delivery = 1, 
    Collection = 2, 
    DeliveryOrCollection = 3, 
}

export class PagedListOfRaffleDto implements IPagedListOfRaffleDto {
    source?: RaffleDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;

    constructor(data?: IPagedListOfRaffleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source.push(RaffleDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfRaffleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfRaffleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }

    clone(): PagedListOfRaffleDto {
        const json = this.toJSON();
        let result = new PagedListOfRaffleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedListOfRaffleDto {
    source?: RaffleDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class MapRaffleToCategoryDto implements IMapRaffleToCategoryDto {
    id: number;
    raffleId: number;
    raffleName?: string | null;
    categoryId: number;
    categoryName?: string | null;
    dateCreated: Date;

    constructor(data?: IMapRaffleToCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.categoryName = data["categoryName"] !== undefined ? data["categoryName"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): MapRaffleToCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapRaffleToCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        return data; 
    }

    clone(): MapRaffleToCategoryDto {
        const json = this.toJSON();
        let result = new MapRaffleToCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IMapRaffleToCategoryDto {
    id: number;
    raffleId: number;
    raffleName?: string | null;
    categoryId: number;
    categoryName?: string | null;
    dateCreated: Date;
}

export class MapRaffleToCategory implements IMapRaffleToCategory {
    id: number;
    categoryId: number;
    raffleId: number;
    categoryName?: string | null;
    raffleName?: string | null;
    dateCreated: Date;

    constructor(data?: IMapRaffleToCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.raffleId = data["raffleId"] !== undefined ? data["raffleId"] : <any>null;
            this.categoryName = data["categoryName"] !== undefined ? data["categoryName"] : <any>null;
            this.raffleName = data["raffleName"] !== undefined ? data["raffleName"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): MapRaffleToCategory {
        data = typeof data === 'object' ? data : {};
        let result = new MapRaffleToCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["raffleId"] = this.raffleId !== undefined ? this.raffleId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["raffleName"] = this.raffleName !== undefined ? this.raffleName : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        return data; 
    }

    clone(): MapRaffleToCategory {
        const json = this.toJSON();
        let result = new MapRaffleToCategory();
        result.init(json);
        return result;
    }
}

export interface IMapRaffleToCategory {
    id: number;
    categoryId: number;
    raffleId: number;
    categoryName?: string | null;
    raffleName?: string | null;
    dateCreated: Date;
}

export class PagedListOfMapRaffleToCategory implements IPagedListOfMapRaffleToCategory {
    source?: MapRaffleToCategory[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;

    constructor(data?: IPagedListOfMapRaffleToCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source.push(MapRaffleToCategory.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfMapRaffleToCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfMapRaffleToCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }

    clone(): PagedListOfMapRaffleToCategory {
        const json = this.toJSON();
        let result = new PagedListOfMapRaffleToCategory();
        result.init(json);
        return result;
    }
}

export interface IPagedListOfMapRaffleToCategory {
    source?: MapRaffleToCategory[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class CreateSectionDto implements ICreateSectionDto {
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
    sectionId: number;

    constructor(data?: ICreateSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        return data; 
    }

    clone(): CreateSectionDto {
        const json = this.toJSON();
        let result = new CreateSectionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSectionDto {
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
    sectionId: number;
}

export class SectionDto implements ISectionDto {
    sectionId: number;
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;

    constructor(data?: ISectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.entityStatus = data["entityStatus"] !== undefined ? data["entityStatus"] : <any>null;
        }
    }

    static fromJS(data: any): SectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["entityStatus"] = this.entityStatus !== undefined ? this.entityStatus : <any>null;
        return data; 
    }

    clone(): SectionDto {
        const json = this.toJSON();
        let result = new SectionDto();
        result.init(json);
        return result;
    }
}

export interface ISectionDto {
    sectionId: number;
    name?: string | null;
    dateCreated: Date;
    description?: string | null;
    entityStatus: EntityStatus;
}

export class InsertTransactionDto implements IInsertTransactionDto {
    walletId: number;
    userId?: string | null;
    amount: number;
    dateOfTransaction: Date;
    transactionType: TransactionTypeEnum;
    status: EntityStatus;
    transactionReference?: string | null;
    description?: string | null;

    constructor(data?: IInsertTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.walletId = data["walletId"] !== undefined ? data["walletId"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.dateOfTransaction = data["dateOfTransaction"] ? new Date(data["dateOfTransaction"].toString()) : <any>null;
            this.transactionType = data["transactionType"] !== undefined ? data["transactionType"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.transactionReference = data["transactionReference"] !== undefined ? data["transactionReference"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): InsertTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["dateOfTransaction"] = this.dateOfTransaction ? this.dateOfTransaction.toISOString() : <any>null;
        data["transactionType"] = this.transactionType !== undefined ? this.transactionType : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["transactionReference"] = this.transactionReference !== undefined ? this.transactionReference : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }

    clone(): InsertTransactionDto {
        const json = this.toJSON();
        let result = new InsertTransactionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertTransactionDto {
    walletId: number;
    userId?: string | null;
    amount: number;
    dateOfTransaction: Date;
    transactionType: TransactionTypeEnum;
    status: EntityStatus;
    transactionReference?: string | null;
    description?: string | null;
}

export class PagedListOfTransactionDto implements IPagedListOfTransactionDto {
    source?: TransactionDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;

    constructor(data?: IPagedListOfTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source.push(TransactionDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }

    clone(): PagedListOfTransactionDto {
        const json = this.toJSON();
        let result = new PagedListOfTransactionDto();
        result.init(json);
        return result;
    }
}

export interface IPagedListOfTransactionDto {
    source?: TransactionDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class InsertWalletDto implements IInsertWalletDto {
    userId?: string | null;
    balance: number;
    dateUpdated: Date;

    constructor(data?: IInsertWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.balance = data["balance"] !== undefined ? data["balance"] : <any>null;
            this.dateUpdated = data["dateUpdated"] ? new Date(data["dateUpdated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): InsertWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>null;
        return data; 
    }

    clone(): InsertWalletDto {
        const json = this.toJSON();
        let result = new InsertWalletDto();
        result.init(json);
        return result;
    }
}

export interface IInsertWalletDto {
    userId?: string | null;
    balance: number;
    dateUpdated: Date;
}

export class PagedListOfWalletDto implements IPagedListOfWalletDto {
    source?: WalletDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;

    constructor(data?: IPagedListOfWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["source"] && data["source"].constructor === Array) {
                this.source = [] as any;
                for (let item of data["source"])
                    this.source.push(WalletDto.fromJS(item));
            }
            this.pageIndex = data["pageIndex"] !== undefined ? data["pageIndex"] : <any>null;
            this.pageSize = data["pageSize"] !== undefined ? data["pageSize"] : <any>null;
            this.filteredCount = data["filteredCount"] !== undefined ? data["filteredCount"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            this.totalPages = data["totalPages"] !== undefined ? data["totalPages"] : <any>null;
            this.hasPreviousPage = data["hasPreviousPage"] !== undefined ? data["hasPreviousPage"] : <any>null;
            this.hasNextPage = data["hasNextPage"] !== undefined ? data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedListOfWalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfWalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.source && this.source.constructor === Array) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["filteredCount"] = this.filteredCount !== undefined ? this.filteredCount : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data; 
    }

    clone(): PagedListOfWalletDto {
        const json = this.toJSON();
        let result = new PagedListOfWalletDto();
        result.init(json);
        return result;
    }
}

export interface IPagedListOfWalletDto {
    source?: WalletDto[] | null;
    pageIndex: number;
    pageSize: number;
    filteredCount: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}